# 数据库

## 1.事务

### 1.1、事务的定义与特性

事务（Transaction）是一个操作序列，逻辑上不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。

**四大特性（即常说的ACID特性）：**

- **原子性（Atomicity）**：一个事务是一个逻辑上不可分割的工作单位，事务中包括的操作要么都做，要么都不做。即事务的所有操作要么全部提交成功，要么全部失败回滚。
- **一致性（Consistency）**：事务的执行必须使数据库保持一致性状态，即使数据库从一个一致性状态变到另一个一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- **隔离性（Isolation）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。也就是说一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- **持久性（Durability）**：一旦事务提交成功，它对数据库中数据的修改是永久性的。

### 1.2、事务特性的实现原理

因为**MySql**的引擎中只有**InnoDB**支持事务，所以这里的实现都讲述的是InnoDB实现事务特性的原理。

首先介绍一下Innodb中的两个事务日志：redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。undo log不是redo log的逆向过程，它们都算是用来恢复的日志。

- **redo log**通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。（用于实现**持久性**）它包括两部分，一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
- **undo log**用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。（用于实现**原子性和隔离性**）除它之外还有binlog（二进制日志）也记录了很多innodb表的操作，也能实现重做的功能，但是他们之间有较大区别，这个后续再讲。

简单介绍一下对数据库的操作步骤：因为数据库信息存储在磁盘当中，所以并不能直接操作他们。需要先加载数据库信息的缓存到内存中，再进行操作，再写回磁盘的文件当中。

**持久性的实现：**事务每次成功提交，代表该次操作已经写入了数据库信息的缓存中，但该缓存并不会马上写到磁盘当中。所以我们人为规定必须还要将此次对缓存的操作写到磁盘中的redo log中去，才算该事务提交成功，那么即使发生了断电/系统崩溃/其它的软硬件错误等情况，导致数据没有被完整写入到磁盘的数据库信息中，也能根据redo log文件将未完成的操作进行重做，以保证持久性。

​	**问题：**为什么不直接每次都必须把数据库信息写回磁盘才算事务提交成功，这样不就不用redo log了？

​	**理由：**因为写入到redo log只需写入一条记录并且是顺序I/O（追加到文件末尾），而对数据库信息的修改是随机I/O（大概率涉及多个表的修改，而它们并不一定是相邻的），每个事务提交前都要等待一次后者的时间是无法接受的，所以选用速度很快的写入redo log。

**原子性的实现：**和前面持久性的实现有些类似，每次操作数据库之前也都会把操作记录到undo log中，如果发生了断电/系统崩溃/其它的软硬件错误等情况，导致有一些事务没有提交但是已经写到了缓存当中，就可以通过undo log中的记录进行操作的回滚，以达到原子性。

**隔离性的实现：**这里是需要分步来说，首先是未提交读（Read Uncommited）级别，该隔离级别不需要其他操作就能达到。然后在MySQL中，使用MVCC来实现提交读（Read Commited）和可重复读（Repeatable Read）这两个隔离级别，使用MVCC+Next-Key Lock来解决幻读的问题。

MVCC是什么？这里需要做一个介绍，简单来说就是在数据表每行中设有隐藏的列，一列是上一次更新过该行数据的事务id，一列是一个指针，指向本数据上一个版本的undo log。（记录了值）

再说明一下RedaView机制，就是当你执行一个事务的时候，会生成几个数值。一个代表此时哪些事务在MySQL中还未提交，一个代表本事务的id，一个代表此时未提交的事务中的最小id，一个代表MySQL下个生成的事务的id。

- **实现提交读：**每次读取数据时，如果该数据最近更新的事务id在未提交事务中，那就根据表中隐藏的指针找到上一次提交了的数据并读取。
- **实现可重复读：**每次select的时候检查所读数据最近更新的事务id号，如果在本次事务之后，那么不会读取，会一直沿指针追溯到更新事务id号小于本事务id号的数据再读取。
- **解决幻读：**使用MVCC+Next-Key Lock。

**InnoDB有三种行锁的算法：**

（1）Record Lock：行锁，即单个行记录上的锁。

（2）Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

（3）Next-Key Lock：行锁加两边的间隙锁，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。（前开后闭的区间）

以我个人的理解来看，保证了原子性、持久性与隔离性，就做到了**一致性**。

## 2.常出现的并发一致性问题

- **丢失修改：**一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。

  例如：事务A把变量a的值从5修改到10，还未提交时另一个事务B又把变量a的值修改为15并成功提交，然后事务A提交，最后变量a的值还是10。相当丢失了事务B的这次修改。

- **脏读：**一个事务读取了被另一个事务修改、但未提交（有可能进行了回滚）的数据，造成两个事务得到的数据不一致。

  例如：事务A修改变量a的值为10，但未提交。此时事务B读取变量a的值为10，然后进行操作。但是事务A之后进行了回滚，变量a的值变回了5。相当于事务B读取到变量错误的值，即读取了脏数据。

- **不可重复读：**在同一个事务中，查询操作在某个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对的update操作）。

  例如：计算变量a+变量a，前面那个a读取的值是50，后面那个读取到的值是100。

- **幻读：**当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集。（和不可重复读的区别：幻读针对一个数据整体/范围，并且针对的是insert操作）。

  例如：多次查询score>60的学生，第一次查询到三个学生，第二次查询到五个学生。

## 3.数据库的隔离级别

- **未提交读（Read Uncommited）：**在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读。（比如某程序更新数据，但是并没有提交，别的程序就可以读取到它。）

  该级别下，select语句不加锁，虽然并发性最高，但是隔离性最差，所以该隔离级别一般不会被使用。

- **提交读（Read Commited）：**一个事务只能看见已经提交的事务所作的改变。可避免脏读问题。

- **可重复读（Repeatable Read）：**可以确保同一个事务在多次读取同样的数据时得到相同的结果。可以理解为事务在读取数据的时候获取了一次当前时刻数据的快照，后续的读取都以快照为参照，所以不受其余事务的影响。但是该隔离级别可能会导致幻读，后续在讲解MVCC的时候会说明不能避免幻读的理由。

  MySql默认隔离级别。可避免脏读 、不可重复读的发生。

- **可串行化（Serializable）：**强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。每次读都需要获得表级共享锁，读写相互都会阻塞。

  虽然可以避免脏读、不可重复读、幻读的发生。但是因为可能导致大量的超时现象和锁竞争，实际很少使用。

## 4.乐观锁和悲观锁

乐观锁和悲观锁在数据库和多线程并发中常被提及，但它们并不是某两个特定的锁，而是两个锁的宏观理念。

- **悲观锁**：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据。应用于数据更新比较频繁的场景。

- **乐观锁**：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试。适用于读多写少的场景。

  乐观锁的实现方式有：

  加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段。

  先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。

## 5.常见的封锁级别

意向锁是 InnoDB （MySQL加的数据引擎）自动加的， 不需要用户干预。 对于UPDATE、DELETE和INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)。对于普通SELECT 语句，InnoDB 不会加任何锁。事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。

**排它锁（Exclusive Lock）/ X锁**：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。

**共享锁（Shared Lock）/ S锁**：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁。

**意向锁（Intention Locks）**：一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁。一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁。IS/IX 锁之间都是兼容的。  

好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性

**封锁粒度**：

MySQL 中提供了两种封锁粒度：**行级锁以及表级锁**。

简单来说即锁住整张表或者锁住一行的数据。

|      | 封锁粒度小                                                 | 封锁粒度大                                                   |
| ---- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 优点 | 锁定的数据量较少，发生锁竞争的可能较小，系统的并发性更好。 | 系统开销较小。（加锁、释放锁、检查锁的状态都需要消耗资源）。 |
| 缺点 | 系统开销较大大。                                           | 锁定的数据量较多，发生锁竞争的可能较大，系统的并发性较差。   |

## 6.三级封锁协议

- **一级封锁协议**：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。

  可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）

- **二级封锁协议**：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。

  可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）

- **三级封锁协议**：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。

  可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）。

## 7.两段锁协议

> **什么是两段锁协议？**
>
> 定义：事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。

也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

事务遵循两段锁协议是保证可串行化调度的充分条件（注意不是充要条件，而是充分条件。即事务遵循两段锁协议一定能保证可串行化调度，但保证可串行化调度不一定需要遵循两段锁协议）。

## 8.MVCC

**多版本并发控制**（Multi-Version Concurrency Control, **MVCC**），MVCC在数据表中每行记录后面都保存有两个隐藏的列，用来存储**更新信息的事务号：DB_TRX_ID**和一个**回滚指针：DB_ROLL_PTR**（指向该行数据上一次修改前的数据，存储在undo log中）。

系统版本号：每开始一个新的事务，系统版本号就会自动递增）。（更新包括增删改）

更新事务号：更新一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号。）

各种操作：

- **插入操作**时，记录创建版本号。
- **删除操作**时，记录删除版本号。
- **更新操作**时，先记录删除版本号，再新增一行记录创建版本号。
- **查询操作**时，要符合以下条件才能被查询出来：删除的版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）。创建的版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

通过版本号减少了锁的争用，提高了系统性能。可以实现提交读和可重复读两种隔离级别，未提交读级别无需使用MVCC。

**快照读**：使用MVCC读取的是快照中的数据，这样可以减少加锁带来的开销。

**当前读**：读取的是最新的数据，需要加锁。

<img src="D:\笔记\Typora\Tpora笔记\图片\undolog版本链.png" alt="undolog版本链" style="zoom:60%;" />

<img src="D:\笔记\Typora\Tpora笔记\图片\ReadView.png" alt="ReadView" style="zoom:80%;" />

> 问题：**MVCC不是有类似生成快照的机制吗，为什么不能解决幻读？**

我们设计一个实际案例：现在假设事务A的版本号为200：

```
select * from user,
-- 其他操作
update user set level=1 where age>0,
select * from user
```

在事务A执行第一次select的语句时，假设查询出了三个用户。然后在事务A执行中间的其他操作时，事务B插入了一条新的用户数据，因为事务B的版本号为300，所以假设此时事务A查询，因为该行数据创建的版本号大于自己的版本号，所以不会被查询出。

但是由于此时事务A刚好执行了下一条更新语句，而且恰好新插入的那行数据满足更新条件，它的更新版本号被修改为事务A的版本号，这导致事务A的第二次查询操作会查询出这条别的事务新插入的数据，这就造成了幻读的问题。

MySQL是使用MVCC+Next Key Lock来解决幻读问题的，关于Next-Key Lock可以看博主数据库基础知识一的介绍。

## 9.数据库的范式

讲解数据库的范式之前，补充一下数据库中的基本概念：

- **主键**：关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键（一张表只有一个，不允许重复，不允许为空）。
- **外键**：外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键（一张表可以有多个，可以有重复的，可以是空值）。
- **元组**：可以理解为数据表的某一行属性：可以理解为数据表的某一列，属性名就是列的字段。
- **候选码**：某一属性组能唯一标识一个元组而其子集不能，则称该属性组为候选码。若有多个候选码，选择其中一个为主码。
- **主属性**：候选码包含的属性（一个或多个）。
- **非主属性**：顾名思义，就是候选码不包括的属性。

![主码候选码等关系](D:\笔记\Typora\Tpora笔记\图片\主码候选码等关系.png)

**范式**：

- **第一范式（1NF，Normal Form）**：属性不应该是可分的。举例：如果将“电话”作为一个属性（即数据表中的一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话。如果将“移动电话”作为一个属性，就符合1NF。

- **第二范式（2NF）**：每个**非主属性完全依赖于主属性集（候选键集）**。B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。

  举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集。

  > **问题：那如何使其满足2NF？**

  可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余； 满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。

- **第三范式（3NF）**：在 2NF 的基础上，非主属性**不传递依赖于主属性**。

  **传递依赖**：如果C依赖于B，B依赖于A，那么C传递依赖于A。3NF在2NF的基础上，消除了非主属性之间的依赖。

  比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）。

  使一个2NF变成3NF的方法同样是分解，方法类似1NF变为2NF，这里不再赘述。

**不符合范式会出现哪些异常？**

- **冗余数据**：某些同样的数据多次出现（如学生姓名）。
- **修改异常**：修改了一个记录中的信息，另一个记录中相同的信息却没有修改。
- **删除异常**：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）。
- **插入异常**：无法插入（插入一个还没有课程信息的学生）。

## 10.常见的表连接方式

先创建两张简单的数据表以作后续的演示：

| 学生表                                                       | 成绩表                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\学生表.png" alt="学生表" style="zoom:100%;" /> | <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\成绩表.png" alt="成绩表" style="zoom:75%;" /> |

**内连接（Inner Join）**：仅将两个表中满足连接条件的行组合起来作为结果集    

- **自然连接**：只考虑属性相同的元组对。    

示例：

```mysql
select * from student natural join grade;
```

结果：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\自然连接结果.png" alt="自然连接结果" style="zoom:67%;" />

没有给任何的条件，数据库自动把两张数据表各行有相同属性的行（元组）连接在了一起。

- **等值/连接**：给定条件进行查询。

示例：

```mysql
select * from student,grade
where student.sno=grade.sno;
```

结果：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\等值连接结果.png" alt="等值连接结果" style="zoom:67%;" />

**外连接（Outer Join）**

- **左连接**：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分（就比如说成绩表和课程表连接，只显示两边有学号相等的，如果某一边的学号另一边没出现，那就不显示），没有对应的部分补NULL。

  示例： 

  ```mysql
  select * from student
  left outer join grade
  on student.sno=grade.sno;
  ```

  结果：

  <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\左连接.png" alt="左连接" style="zoom:67%;" />

- **右连接**：和左连接相反。    

  示例：

  ```mysql
  select * from student
  left outer join grade
  on student.sno=grade.sno;
  ```

  结果：

  <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\右连接.png" alt="右连接" style="zoom:67%;" />

- **全外连接（Full Outer Join）**：查询出左表和右表所有数据，但是去除两表的重复数据。

  示例：

  原本SQL语句只应该需要类似：

  ```
  select * from student
  full outer join grade 
  on student.sno=grade.sno;
  ```

  但因为MySQL不支持这样的全外连接，所以我们使用UNION来达到全外连接的效果：

  ```mysql
  select * from student
  left join grade on student.sno=grade.sno
  union
  select * from student
  right join grade on student.sno=grade.sno;
  ```

  结果：

  <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\全外连接.png" alt="全外连接" style="zoom:67%;" />

**交叉连接（Cross Join）**：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）。

示例：

```mysql
select * from student,grade;
```

结果：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\笛卡尔积.png" alt="笛卡尔积" style="zoom:67%;" />
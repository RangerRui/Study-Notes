# 数据库基础

## 1、事务

### 1.1、事务的定义与特性

事务（Transaction）是一个操作序列，逻辑上不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。

**四大特性（即常说的ACID特性）：**

- **原子性（Atomicity）**：一个事务是一个逻辑上不可分割的工作单位，事务中包括的操作要么都做，要么都不做。即事务的所有操作要么全部提交成功，要么全部失败回滚。
- **一致性（Consistency）**：事务的执行必须使数据库保持一致性状态，即使数据库从一个一致性状态变到另一个一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- **隔离性（Isolation）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。也就是说一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- **持久性（Durability）**：一旦事务提交成功，它对数据库中数据的修改是永久性的。

### 1.2、事务特性的实现原理

因为**MySql**的引擎中只有**InnoDB**支持事务，所以这里的实现都讲述的是InnoDB实现事务特性的原理。

首先介绍一下Innodb中的两个事务日志：redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。undo log不是redo log的逆向过程，它们都算是用来恢复的日志。

- **redo log**通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。（用于实现**持久性**）它包括两部分，一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
- **undo log**用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。（用于实现**原子性和隔离性**）除它之外还有binlog（二进制日志）也记录了很多innodb表的操作，也能实现重做的功能，但是他们之间有较大区别，这个后续再讲。

简单介绍一下对数据库的操作步骤：因为数据库信息存储在磁盘当中，所以并不能直接操作他们。需要先加载数据库信息的缓存到内存中，再进行操作，再写回磁盘的文件当中。

**持久性的实现：**事务每次成功提交，代表该次操作已经写入了数据库信息的缓存中，但该缓存并不会马上写到磁盘当中。所以我们人为规定必须还要将此次对缓存的操作写到磁盘中的redo log中去，才算该事务提交成功，那么即使发生了断电/系统崩溃/其它的软硬件错误等情况，导致数据没有被完整写入到磁盘的数据库信息中，也能根据redo log文件将未完成的操作进行重做，以保证持久性。

​	**问题：**为什么不直接每次都必须把数据库信息写回磁盘才算事务提交成功，这样不就不用redo log了？

​	**理由：**因为写入到redo log只需写入一条记录并且是顺序I/O（追加到文件末尾），而对数据库信息的修改是随机I/O（大概率涉及多个表的修改，而它们并不一定是相邻的），每个事务提交前都要等待一次后者的时间是无法接受的，所以选用速度很快的写入redo log。

**原子性的实现：**和前面持久性的实现有些类似，每次操作数据库之前也都会把操作记录到undo log中，如果发生了断电/系统崩溃/其它的软硬件错误等情况，导致有一些事务没有提交但是已经写到了缓存当中，就可以通过undo log中的记录进行操作的回滚，以达到原子性。

**隔离性的实现：**这里是需要分步来说，首先是未提交读（Read Uncommited）级别，该隔离级别不需要其他操作就能达到。然后在MySQL中，使用MVCC来实现提交读（Read Commited）和可重复读（Repeatable Read）这两个隔离级别，使用MVCC+Next-Key Lock来解决幻读的问题。

MVCC是什么？这里需要做一个介绍，简单来说就是在数据表每行中设有隐藏的列，一列是上一次更新过该行数据的事务id，一列是一个指针，指向本数据上一个版本的undo log。（记录了值）

再说明一下RedaView机制，就是当你执行一个事务的时候，会生成几个数值。一个代表此时哪些事务在MySQL中还未提交，一个代表本事务的id，一个代表此时未提交的事务中的最小id，一个代表MySQL下个生成的事务的id。

- **实现提交读：**每次读取数据时，如果该数据最近更新的事务id在未提交事务中，那就根据表中隐藏的指针找到上一次提交了的数据并读取。
- **实现可重复读：**每次select的时候检查所读数据最近更新的事务id号，如果在本次事务之后，那么不会读取，会一直沿指针追溯到更新事务id号小于本事务id号的数据再读取。
- **解决幻读：**使用MVCC+Next-Key Lock。

**InnoDB有三种行锁的算法：**

（1）Record Lock：行锁，即单个行记录上的锁。

（2）Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

（3）Next-Key Lock：行锁加两边的间隙锁，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。（前开后闭的区间）

以我个人的理解来看，保证了原子性、持久性与隔离性，就做到了**一致性**。

## 2、常出现的并发一致性问题

- **丢失修改：**一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。

  例如：事务A把变量a的值从5修改到10，还未提交时另一个事务B又把变量a的值修改为15并成功提交，然后事务A提交，最后变量a的值还是10。相当丢失了事务B的这次修改。

- **脏读：**一个事务读取了被另一个事务修改、但未提交（有可能进行了回滚）的数据，造成两个事务得到的数据不一致。

  例如：事务A修改变量a的值为10，但未提交。此时事务B读取变量a的值为10，然后进行操作。但是事务A之后进行了回滚，变量a的值变回了5。相当于事务B读取到变量错误的值，即读取了脏数据。

- **不可重复读：**在同一个事务中，查询操作在某个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对的update操作）。

  例如：计算变量a+变量a，前面那个a读取的值是50，后面那个读取到的值是100。

- **幻读：**当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集。（和不可重复读的区别：幻读针对一个数据整体/范围，并且针对的是insert操作）。

  例如：多次查询score>60的学生，第一次查询到三个学生，第二次查询到五个学生。

## 3、数据库的隔离级别

- **未提交读（Read Uncommited）：**在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读。（比如某程序更新数据，但是并没有提交，别的程序就可以读取到它。）

  该级别下，select语句不加锁，虽然并发性最高，但是隔离性最差，所以该隔离级别一般不会被使用。

- **提交读（Read Commited）：**一个事务只能看见已经提交的事务所作的改变。可避免脏读问题。

- **可重复读（Repeatable Read）：**可以确保同一个事务在多次读取同样的数据时得到相同的结果。可以理解为事务在读取数据的时候获取了一次当前时刻数据的快照，后续的读取都以快照为参照，所以不受其余事务的影响。但是该隔离级别可能会导致幻读，后续在讲解MVCC的时候会说明不能避免幻读的理由。

  MySql默认隔离级别。可避免脏读 、不可重复读的发生。

- **可串行化（Serializable）：**强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。每次读都需要获得表级共享锁，读写相互都会阻塞。

  虽然可以避免脏读、不可重复读、幻读的发生。但是因为可能导致大量的超时现象和锁竞争，实际很少使用。

## 4、乐观锁和悲观锁

乐观锁和悲观锁在数据库和多线程并发中常被提及，但它们并不是某两个特定的锁，而是两个锁的宏观理念。

- **悲观锁**：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据。应用于数据更新比较频繁的场景。

- **乐观锁**：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试。适用于读多写少的场景。

  乐观锁的实现方式有：

  加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段。

  先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。

## 5、常见的封锁级别

​	意向锁是 InnoDB （MySQL加的数据引擎）自动加的， 不需要用户干预。 对于UPDATE、DELETE和INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)。对于普通SELECT 语句，InnoDB 不会加任何锁。事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。

**排它锁（Exclusive Lock）/ X锁**：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。

**共享锁（Shared Lock）/ S锁**：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁。

**意向锁（Intention Locks）**：一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁。一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁。IS/IX 锁之间都是兼容的。  

好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性

**封锁粒度**：

MySQL 中提供了两种封锁粒度：**行级锁以及表级锁**。

简单来说即锁住整张表或者锁住一行的数据。

|      | 封锁粒度小                                                 | 封锁粒度大                                                   |
| ---- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 优点 | 锁定的数据量较少，发生锁竞争的可能较小，系统的并发性更好。 | 系统开销较小。（加锁、释放锁、检查锁的状态都需要消耗资源）。 |
| 缺点 | 系统开销较大大。                                           | 锁定的数据量较多，发生锁竞争的可能较大，系统的并发性较差。   |

## 6、三级封锁协议

- **一级封锁协议**：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。

  可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）

- **二级封锁协议**：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。

  可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）

- **三级封锁协议**：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。

  可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）。

## 7、两段锁协议

> **什么是两段锁协议？**
>
> 定义：事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。

也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

事务遵循两段锁协议是保证可串行化调度的充分条件（注意不是充要条件，而是充分条件。即事务遵循两段锁协议一定能保证可串行化调度，但保证可串行化调度不一定需要遵循两段锁协议）。

## 8、MVCC

**多版本并发控制**（Multi-Version Concurrency Control, **MVCC**），MVCC在数据表中每行记录后面都保存有两个隐藏的列，用来存储**更新信息的事务号：DB_TRX_ID**和一个**回滚指针：DB_ROLL_PTR**（指向该行数据上一次修改前的数据，存储在undo log中）。

系统版本号：每开始一个新的事务，系统版本号就会自动递增）。（更新包括增删改）

更新事务号：更新一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号。）

各种操作：

- **插入操作**时，记录创建版本号。
- **删除操作**时，记录删除版本号。
- **更新操作**时，先记录删除版本号，再新增一行记录创建版本号。
- **查询操作**时，要符合以下条件才能被查询出来：删除的版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）。创建的版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

通过版本号减少了锁的争用，提高了系统性能。可以实现提交读和可重复读两种隔离级别，未提交读级别无需使用MVCC。

**快照读**：使用MVCC读取的是快照中的数据，这样可以减少加锁带来的开销。

**当前读**：读取的是最新的数据，需要加锁。

<img src="D:\笔记\Typora\Tpora笔记\图片\undolog版本链.png" alt="undolog版本链" style="zoom:60%;" />

<img src="D:\笔记\Typora\Tpora笔记\图片\ReadView.png" alt="ReadView" style="zoom:80%;" />

> 问题：**MVCC不是有类似生成快照的机制吗，为什么不能解决幻读？**

我们设计一个实际案例：现在假设事务A的版本号为200：

```
select * from user,
-- 其他操作
update user set level=1 where age>0,
select * from user
```

在事务A执行第一次select的语句时，假设查询出了三个用户。然后在事务A执行中间的其他操作时，事务B插入了一条新的用户数据，因为事务B的版本号为300，所以假设此时事务A查询，因为该行数据创建的版本号大于自己的版本号，所以不会被查询出。

但是由于此时事务A刚好执行了下一条更新语句，而且恰好新插入的那行数据满足更新条件，它的更新版本号被修改为事务A的版本号，这导致事务A的第二次查询操作会查询出这条别的事务新插入的数据，这就造成了幻读的问题。

MySQL是使用MVCC+Next Key Lock来解决幻读问题的，关于Next-Key Lock可以看博主数据库基础知识一的介绍。

## 9、数据库的范式

讲解数据库的范式之前，补充一下数据库中的基本概念：

- **主键**：关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键（一张表只有一个，不允许重复，不允许为空）。
- **外键**：外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键（一张表可以有多个，可以有重复的，可以是空值）。
- **元组**：可以理解为数据表的某一行属性：可以理解为数据表的某一列，属性名就是列的字段。
- **候选码**：某一属性组能唯一标识一个元组而其子集不能，则称该属性组为候选码。若有多个候选码，选择其中一个为主码。
- **主属性**：候选码包含的属性（一个或多个）。
- **非主属性**：顾名思义，就是候选码不包括的属性。

![主码候选码等关系](D:\笔记\Typora\Tpora笔记\图片\主码候选码等关系.png)

**范式**：

- **第一范式（1NF，Normal Form）**：属性不应该是可分的。举例：如果将“电话”作为一个属性（即数据表中的一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话。如果将“移动电话”作为一个属性，就符合1NF。

- **第二范式（2NF）**：每个**非主属性完全依赖于主属性集（候选键集）**。B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。

  举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集。

  > **问题：那如何使其满足2NF？**

  可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余； 满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。

- **第三范式（3NF）**：在 2NF 的基础上，非主属性**不传递依赖于主属性**。

  **传递依赖**：如果C依赖于B，B依赖于A，那么C传递依赖于A。3NF在2NF的基础上，消除了非主属性之间的依赖。

  比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）。

  使一个2NF变成3NF的方法同样是分解，方法类似1NF变为2NF，这里不再赘述。

**不符合范式会出现哪些异常？**

- **冗余数据**：某些同样的数据多次出现（如学生姓名）。
- **修改异常**：修改了一个记录中的信息，另一个记录中相同的信息却没有修改。
- **删除异常**：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）。
- **插入异常**：无法插入（插入一个还没有课程信息的学生）。

## 10、常见的表连接方式

先创建两张简单的数据表以作后续的演示：

| 学生表                                                       | 成绩表                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\学生表.png" alt="学生表" style="zoom:100%;" /> | <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\成绩表.png" alt="成绩表" style="zoom:75%;" /> |

**内连接（Inner Join）**：仅将两个表中满足连接条件的行组合起来作为结果集    

- **自然连接**：只考虑属性相同的元组对。    

示例：

```mysql
select * from student natural join grade;
```

结果：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\自然连接结果.png" alt="自然连接结果" style="zoom:67%;" />

没有给任何的条件，数据库自动把两张数据表各行有相同属性的行（元组）连接在了一起。

- **等值/连接**：给定条件进行查询。

示例：

```mysql
select * from student,grade
where student.sno=grade.sno;
```

结果：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\等值连接结果.png" alt="等值连接结果" style="zoom:67%;" />

**外连接（Outer Join）**

- **左连接**：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分（就比如说成绩表和课程表连接，只显示两边有学号相等的，如果某一边的学号另一边没出现，那就不显示），没有对应的部分补NULL。

  示例： 

  ```mysql
  select * from student
  left outer join grade
  on student.sno=grade.sno;
  ```

  结果：

  <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\左连接.png" alt="左连接" style="zoom:67%;" />

- **右连接**：和左连接相反。    

  示例：

  ```mysql
  select * from student
  left outer join grade
  on student.sno=grade.sno;
  ```

  结果：

  <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\右连接.png" alt="右连接" style="zoom:67%;" />

- **全外连接（Full Outer Join）**：查询出左表和右表所有数据，但是去除两表的重复数据。

  示例：

  原本SQL语句只应该需要类似：

  ```
  select * from student
  full outer join grade 
  on student.sno=grade.sno;
  ```

  但因为MySQL不支持这样的全外连接，所以我们使用UNION来达到全外连接的效果：

  ```mysql
  select * from student
  left join grade on student.sno=grade.sno
  union
  select * from student
  right join grade on student.sno=grade.sno;
  ```

  结果：

  <img src="D:\笔记\Typora\Tpora笔记\图片\数据库\全外连接.png" alt="全外连接" style="zoom:67%;" />

**交叉连接（Cross Join）**：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）。

示例：

```mysql
select * from student,grade;
```

结果：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\笛卡尔积.png" alt="笛卡尔积" style="zoom:67%;" />

## 11、存储过程

​	**存储过程**是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。

**优点**：

- 预先编译，而不需要每次运行时编译，提高了数据库执行效率。
- 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量。
- 具有可复用性，减少了数据库开发的工作量。
- 安全性高，可以让没有权限的用户通过存储过程间接操作数据库。
- 更易于维护。

**缺点**：

- 可移植性差，存储过程将应用程序绑定到了数据库上。
- 开发调试复杂。
- 修改复杂，需要重新编译，有时还需要更新程序中的代码以更新调用。

> **Drop/Delete/Truncate的区别？**

Delete用来删除表的全部或者部分数据，执行delete之后，用户需要提交之后才会执行，会触发表上的DELETE触发器（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；

Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1。

Drop命令从数据库中删除表，所有的数据行，索引和约束都会被删除。不能回滚，不会触发触发器。

> **触发器是什么？**

触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于保证数据完整性（比如可以检验或转换数据）。

> **有哪些约束类型？**

约束（Constraint）类型：

- 主键（Primary Key）约束
- 唯一约束（Unique）
- 检查约束
- 非空约束
- 外键（Foreign Key）约束



## 12、视图、游标

**视图**：

​	从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中只存放视图的定义，而不存放视图的数据）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）。

可以跟基本表一样，进行增删改查操作(**增删改操作有条件限制，一般视图只允许查询操作**)，对视图的增删改也会影响原表的数据。**它就像一个窗口，透过它可以看到数据库中自己感兴趣的数据并且操作它们。**好处：

- 通过只给用户访问视图的权限，保证数据的安全性。
- 可以通过对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。
- 可以通过视图使用户以多种角度看待同一数据，比如不同种类的用户共享一个数据库。（通过权限？）
- 简化复杂的SQL操作（比如原来查的内容是几张几百列的数据表，而我们只关心其中几个数据，那我们可以建立一个视图，直接在视图中查询它们，可以提高很多效率），隐藏数据的复杂性（比如复杂的连接）。

**游标（Cursor）**：

​	用于定位在查询返回的结果集的特定行，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。它是一段私有的SQL工作区，也就是一段内存区域，用于暂时存放受SQL语句影响的数据，简单来说，就是将受影响的数据暂时放到了一个内存区域的虚表当中，这个虚表就是游标。

​	游标是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。即游标用来逐行读取结果集。游标充当指针的作用。尽管游标能遍历结果中的所有行，但他一次只指向一行。

​	游标的一个常见用途就是保存查询结果，以便以后使用。游标的结果集是由SELECT语句产生，如果处理过程需要重复使用一个记录集，那么创建一次游标而重复使用若干次，比重复查询数据库要快的多。通俗来说，游标就是能在sql的查询结果中，显示某一行（或某多行）数据，其查询的结果不是数据表，而是已经查询出来的结果集。

**简单来说：游标就是在查询出的结果集中进行选择性操作的工具。**



## **13、SQL语句的优化**

- 应尽量避免在 where 子句中使用!=、<、>操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描；
- 只返回必要的列：最好不要使用 SELECT * 语句；
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据；
- 将一个大连接查询分解成对每一个表进行一次单表查询，然后进行关联，这样做的好处有：

​	让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询。减少锁竞争。

## 14、索引

​	索引是对数据库表中一列或多列的值进行排序的一种结构（说明是在列上建立的），使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

​	当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作。第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。

   例如这样一个查询：select * from table1 where id=10000。如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止。有了索引之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于索引是经过某种算法优化过的，因而查找次数要少的多。可见，索引是用来定位的。

数据库索引好比一本书前面的目录，能加快数据库的查询顺序。索引从物理结构上分为**聚簇索引**和**非聚簇索引**：

- （1）**聚簇索引**对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。按照数据存放的物理位置为顺序，每张数据表只能创建一个聚簇索引（因为要改变物理存储顺序），与非聚簇索引相比查询数据速度很快，进行修改的速度较慢。主键索引就是一种聚簇索引。
- InnoDB表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个NOT NULL 的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个隐式自增id列并在此列上创建聚簇索引。
- （2）**非聚簇索引**（也叫二级索引/辅助索引）只记录逻辑顺序，并不改变物理顺序。通过索引记录地址访问表中的数据。索引的逻辑顺序和表中行的物理存储顺序不同。Innodb使用的是聚簇索引，MyISam使用的是非聚簇索引

从应用上分，**主键索引（聚集）**，**唯一索引（聚集/非聚集）**，**普通索引**，**组合索引**，**单列索引和全文索引**

- （3）**唯一索引（UNIQUE）**：索引列的值必须唯一，允许有空值。
- （4）**主键索引 PRIMARY KEY**：必须唯一，不允许空值（是一种特殊的唯一索引。表中只有一个，MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）。当列添加主键约束时，自动添加主键索引。
- （5）**普通索引**：用表中的普通列构建的索引，没有任何限制，用于加速查询。
- （6）**组合索引（复合索引）**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- （7）**全文索引**：先定义一个词库，然后在文章中查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳，这样就相当于对文件建立了一个以词库为目录的索引，这样查找某个词的时候就能很快的定位到该词出现的位置。

**索引的优点**：

- 大大加快了数据的检索速度。
- 显著减少查询中分组和排序的时间。
- 通过创建唯一性索引，可以保证数据库表中的某一行数据的唯一性。
- 将随机I/O变为了顺序I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

**索引的缺点**：

- 创建和维护索引组要耗费时间，并且随着数据量的增加所耗费的时间也会增加。
- 索引需要占磁盘空间，除了数据表占数据空间以外，每一个索引还要占一定的物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。

**索引失效的情况？**

- 以“%(表示任意0个或多个字符)”开头的LIKE语句。
- OR条件中的每个列没有同时使用索引。
- 对于多列索引，必须满足 最左匹配原则/最左前缀原则 (最左优先：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。
- 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）。

**哪些地方适合创建索引？**

- 某列经常作为最大最小值。
- 经常被查询的字段。
- 经常用作表连接的字段。
- 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段

**创建索引需要注意的**：

- 只应建立在小字段上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）。

- 建立索引的字段应该非空，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL。
- 选择数据密度大（唯一值占总数的百分比很大）的字段作索引。

# MySQL基础

## 1、MySQL中的索引

在MySQL，索引是由B+树实现的，B+是一种与B树十分类似的数据结构。

形如下面这种：

<img src="D:\笔记\Typora\Tpora笔记\图片\数据库\B+树.png" alt="B+树" style="zoom:67%;" />

**其结构特点**：

（1）有n课子树的结点中含有n个关键码。

（2）非根节点子节点数： **ceil(m/2)<= k <= m**（ceil是天花板函数的意思，也就是向上取整，比如**ceil(1.2)=2** ），m为该B+树的阶数。根节点最少有两个子节点，最多同样为m个。

（2）叶子节点包含了全部关键码的信息，及指向含有这些关键码记录的指针。并且叶子节点根据关键码的大小自小至大的顺序链接，叶子节点有相邻结点的指针。

（3）所有的非叶子节点（B+树中也称内部结点，索引节点）可以看成索引部分，都不存储数据，只存储索引，结点中仅含有其子树根节点中最大（或者最小）的关键码，数据都存储在叶子节点中。

> **问题：为什么索引不适用B树而是B+树实现？**

B+树比B树的优点：

- **IO次数少**：B+树的中间节点只存放索引，数据都存在叶子节点中，所以结点中存取的数据更多，使得B+树更加矮胖，因此可以减少I/O次数。（这里IO指的是磁盘I/O，每一次查询，需要把某结点读到内存，然后把目标数和结点中的比较，不一样则继续I/O）

- **范围查询效率更高**：B树需要中序遍历整个树，B+树只需要遍历叶子结点中的链表。

- **查询效率更加稳定**：B树查询某个数据最好情况只需到根节点，而最坏情况需要遍历整个二叉树。

  B+树每次查询都需要从根节点到叶子结点，路径长度相同，每次查询效率接近。

> **问题：为什么不采用效率更高的哈希查找？**

采用B+树索引与哈希索引的比较：

哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组。B+树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。

## 2、MySQL的两种数据库引擎

（1）**InnoDB（in-no-db）**

- 支持事务，可以进行Commit和Rollback。
- 支持表级锁和行级锁，增强了并发性。
- 支持外键。
- 支持在线热备份。

（2）**MyISAM（mai-ai-zem）**

- 不支持事务
- 只支持表级锁，不支持行级锁
- 不支持外键
- MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢MyISAM 支持压缩表和空间数据索引，比InnoDB需要的内存和存储更少MyISAM 管理非事务表。

它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM。InnoDB 支持事务，并发情况下有很好的性能，基本可以替代MyISAM。

> **热备份和冷备份**

**热备份**：在数据库运行的情况下备份的方法。

优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错。

**冷备份**：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。

优点：操作简单快速，恢复简单。

## 3、主从复制

 主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。

实现原理：

- 主服务器 binary log dump 线程：将主服务器中的数据更改（增删改）日志写入 Binary log 中。
- 从服务器 I/O 线程：负责从主服务器读取binary log，并写入本地的 Relay log。
- 从服务器 SQL 线程：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性。

## 4、关系型数据库和非关系型数据库

**关系型数据库（如MySQL）**：
表和表、表和字段、数据和数据存在着关系，它通过数据、关系和对数据的约束三者组成的数据模型来存放和管理数据。
**优点**:

- 数据之间存在关系，进行数据的增删改查的时候较为方便。
- 关系型数据库是有事务操作的，便于保证数据的完整性和一致性。
- 可以通用SQL语言，便于操作者学习使用。

**缺点**：

- 因为数据和数据是有关系的，底层会运行相关的算法，大量算法会降低系统的效率，会降低性能。
- 面对海量数据的增删改查和维护的时候会显的无能为力。
- 因为是固定的表结构类型，所以灵活度较低。

**非关系数据库（如redis和MangDB）**
非关系型数据库严格上不是一种数据库，而是一种数据结构化存储方法的集合，可以是文档或者键值对等。
为了处理大量数据，非关系数据库设计之初就是为了去替代关系型数据库。
优点：

- 存储格式较为灵活，存储数据的格式可以是key-value，文档，图片形式等等，应用成精更加的广泛。
- 速度更快，不仅支持硬盘这样的载体，还支持另外的存储器来存储数据，如Redis就支持内存来存储数据。
- 能支持对大量数据的查找和读写。

缺点：

- 不支持SQL语言的通用，需要单独去学习其操作使用。
- 非关系数据库一般没有事务处理，较难保证数据的完整性和安全性。
- 数据结构较复杂，如果要进行复杂的查询会加大难度。










# 计算机网络

## 1、TCP/UDP相关

### 1.1 、TCP建立连接过程（三次握手）

TCP协议包结构：

<img src="D:\笔记\Typora\Tpora笔记\图片\计算机网络\TCP协议包结构.png" alt="TCP协议包结构" style="zoom:67%;" />

<img src="D:\笔记\Typora\Tpora笔记\图片\三次握手.png" alt="三次握手" style="zoom:70%;" />

（1）**第一次握手**
客户端（Client）向服务器（Server）发送一个SYN段(在 TCP 标头中 SYN 位字段为 1 的 TCP/IP 数据包)，该段中也包含一个客户端的初始序列号（Sequence number = x，seq）。

（2）**第二次握手**
服务器端返回一个 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)，该段中包含服务器的初始序列号(Sequence number = y)。同时使 Acknowledgment number = x + 1来表示确认已收到客户端的 SYN段(Sequence number = y)。

（3）**第三次握手**
客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 1 的 TCP/IP 数据包)（SYN已变为0）, 该段中使 Acknowledgment number = y+ 1来表示确认已收到服务器的 SYN段(Sequence number = y)，自己的序列号则是变成seq=x+1。

> **常见面试问题：为什么是三次握手，不能是两次握手吗？**

答：如果只是两次握手，那么按照上述C/S模型的流程，第二次握手后服务器端会认为自己已经与客户端建立了连接，假如此时网络出现问题，丢失了第二次握手的报文。那么客户端没有收到应答报文，他认为与服务器端并没有建立连接，那么之后服务器端向客户端发来的消息，客户端并不会接受，而是一直等待应答报文，会形成类似死锁的问题。



### 1.2、TCP断开连接过程（四次挥手）

<img src="D:\笔记\Typora\Tpora笔记\图片\计算机网络\四次挥手.png" alt="四次挥手" style="zoom:67%;" />

数据传输结束后，通信的双方都可以释放连接。现在A和B都处于ESTABLISHED状态。

（1）**第一次挥手**

A的应用程序先向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部的**FIN置1**，其序号**seq=x**。这时A进入**FIN-WAIT-1（终止等待1）**状态，等待B的确认（请注意：TCP规定，FIN报文段即使不携带数据，它也要消耗一个序号）。

（2）**第二次挥手**

B收到连接释放报文段后即发出确认，确认号是**ack=x+1**，序号为**seq=y**。然后B就进入**CLOSE-WAIT（关闭等待）**状态。TCP服务器进程这时应通知高层进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭。这个状态可能会持续一些时间。

A收到来自B的确认后，就进入**FIN-WAIT-2**（终止等待2）状态，等待B发出的连接释放报文段。

（3）**第三次挥手**

若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段需要**置FIN=1**。现假定B的序号为z（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号**ack=x+1**。这时B就进入了**LAST-ACK**（最后确认）状态，等待A的确认。  

（4）**第四次挥手**

A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把**ACK置1**，**确认号ack=z+1**，而自己的序号是**seq=u+1**（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到**TIME-WAIT**（时间等待）状态（请注意：现在TCP连接还没有释放掉。必须经过时间等待计时器设置的时间2MSL（MSL：最长报文段寿命）后，A才进入到CLOSED状态）。



> **常见面试问题一：为什么是四次握手，不能是三次握手吗？**

答：与之前需要三次握手的原因类似，如果只是三次挥手，那就相当于服务器端发送完第三次挥手的报文后直接进入**CLOSED**（关闭）状态，假如此时网络出现问题，丢失了第三次挥手的报文，相当于客户端没有收到，那他依旧认为连接没有结束，在一段时间没有收到第二次ACK应答报文后，他会重新发送请求断开连接的报文，但是服务器端已经关闭，不会再接收报文，又形成了类似死锁的情况。



> **常见面试题二：为什么有CLOSE-WAIT状态？**

答：因为服务器端收到断开TCP连接请求时，有可能还有数据没有向客户端发送完毕，需要一段时间来把所有信息传输完毕。



>**常见面试题三：为什么有TIME-WAIT状态？**

答：假设客户端发送完第四次挥手的报文后，直接进入**CLOSED**（关闭）状态。那么假设此时网络出现问题，报文丢失，那么因为服务器端收不到第四次挥手的ACK报文段，所以认为此时TCP连接还没有断开。然后重发**ACK+FIN**报文段，但此时客户端已经关闭与其的TCP连接，肯定不会再接收该报文，这样会浪费大量资源。



>**常见面试题四：什么情况下会出现大量的TIME-WAIT状态？该怎么解决？**

答：在高并发且短连接的通信情况下，服务器会出现大量TIME-WAIT状态，这占用了大量的socket，会影响服务器的正常通信服务。

**解决方法**：

- （1）降低time_wait的时限。
- （2）设置中允许重用time_wait的socket。
- （3）设置快速回收time_wait的socket
- （4）用一个类似Keep-alive的设置，即一定时间探测一下对端是否活跃，如果关闭了之后探测到无响应，那么直接关闭（同样消耗资源，但是能防止没有socket可用）。

### 1.3、TCP的流量控制

使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 **receiver window（窗口大小单位是字节）**，接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

发送窗口的上限为**接受窗口和拥塞窗口中的较小值**。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。

> **问题：接收窗口为0时会如何？**

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。



### 1.4、TCP的拥塞控制

**超时重传机制**

超时重传机制主要是为了解决数据包在传输过程中丢失的问题。

TCP每发送一个报文段，就会为这个报文段开启一个定时器，如果定时器溢出时仍然没有收到接收端的应答报文，那么TCP就认为这个报文段在传输过程中丢失，然后重新发送这个报文段。这便是超时重传机制

举例：客户端请求发送”and hi”报文段时启动了定时器，然而在规定的时间内没有收到对端的回复，所以重新发送”and hi”报文段，并重启定时器(重启的定时器时间会增大)。

**拥塞控制：**

超时重传是为了解决数据丢失的问题，而数据丢失的原因很大程序上是由于传输路径拥塞导致的。

在正常的传输过程中，数据是从一个路由器跳到下一个路由器，每个路由器都有自己的缓冲区，新来的数据会存放在缓冲区中，与此同时路由器也在不断地将缓冲区中的数据发送给下一个路由器。但是如果某个路由器接收数据的速率大于发送数据的速率，就会导致缓冲区数据累积，最终填满缓冲区。此时如果再有数据到来，缓冲区已经无法容纳它们，只能将它们丢掉，造成数据丢失，这就是所谓的拥塞现象，本质就是传输路径上的节点不平衡。为了解决这一问题，就需要当出现拥塞现象时立即减少发送端发送的数据量，为路径上的某些节点提供清空缓冲区的时间，同时也避免了不必要的重传。

但是，发送端如何才能得知网络中发生了拥塞呢。因为由于硬件错误造成的数据丢失是很罕见的，所以发送端假定，如果出现了数据丢失，那么就可以认定发生了拥塞。

发送方维持一个叫做**拥塞窗口cwnd（congestion window）**的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，**发送窗口等于拥塞窗口和接收窗口中的最小值**。

**四个传输过程中的算法：**

（1）慢开始

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。

 刚开始发送数据时，先把**拥塞窗口（congestion window，cwnd）**设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍（指数增长）。比如，第一轮传一个，收到一个加一个，cwnd变为2MSS。第二轮传两个，收到两个加两个，cwnd变为4MSS。

（2）拥塞避免

当**拥塞窗口的大小达到慢开始门限(slow start threshold)**时，拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

无论是在**慢开始阶段**还是在**拥塞避免阶段**，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

（3）快重传

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的**重传计时器时间**到期。

（4）快恢复

当发送方连续收到三个重复确认时，就把**慢开始门限**和**拥塞窗口**减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。

### 1.5、TCP和UDP的区别

TCP是面向连接的，需要三次握手，UDP是面向非连接的。TCP需要保证数据传输到（可靠），而UDP只管发送数据，不关心数据能否到达接收方（不可靠）。UDP的传送速度比TCP更快，所需资源比TCP更少。

## 2、模型层

### 2.1、OSI模型层

- **应用层**：为应用程序之间传输信息，提供网络服务
- **表示层**：处理数据格式，数据加密等
- **会话层**：建立，维护和管理会话
- **传输层**：提供主机端到端连接，流量控制，差错校验以及重传，即保证传递信息的正确无误
- **网络层**：寻址和路由选走，拥塞控制数据
- **数据链路层**：提供介质选择，数据链路的建立和维持
- **物理层**：定义通信传输介质的物理特性

### 2.2、TCP/IP模型层

- **应用层**（对应OSI模型层中的应用层、表示层和会话层）
- **传输层**
- **网络层**
- **网络接口层**（对应OSI模型层中的数据链路层和物理层）

## 3、HTTP相关

### 3.1、简介

超文本传输协议（应用层），端口号80，常承载在TCP之上。

### 3.2、HTTPS和HTTP的区别

**简述HTTPS流程**：

（1）客户端和服务器端传输数据之前，会通过**证书对双方进行身份验证**。客户端发起**SSL握手消息**，服务器发证书给客户端，客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中**获得客户端的公钥**，一般为1024位或者2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。

（2）协商加密算法（客户端发送自己所有支持的加密算法，服务器选择安全性最高的哪一个）后，客户端生成一个随机字符串，用服务器端公钥将其加密发给服务器端，并对哈希计算出的摘要使用之前产生的密钥加密（对称加密）。

（3）服务器端根据自己的私钥进行解密，得出对称加密的密钥，用其解密出Hash摘要值，并自己hash该消息验证摘要值是否一致，一致则使用这个对称密钥。

**常用加密算法**：

**签名加密算法**：MD5（哈希函数）SHA1（与MD5一样都是消息摘要算法，加密性更强）

**对称加密算法**：DES，AES

**非对称加密算法**：RSA，ECC



**HTTPS与HTTP的区别**：

- （1）HTTP使用80端口，HTTPS使用443端口，并在HTTP和TCP之间加入一个加密/身份验证层。

- （2）HTTP信息是明文传输的，HTTP唯一的数据完整性校验就是就是报文头部包含本次运输数据的长度，而对内容是否被篡改不做确认，所以中间人攻击很轻松。而HTTPS运行在TSL/SSL上，添加了加密和认证机制。

- （3）HTTPS由于加密解密，会比HTTP的开销更大。

- （4）HTTPS通信时需要证书，一般需要向证书颁发机构（CA）购买。


### 3.3、HTTP状态码

（1）**100状态码：服务器收到请求，需要请求者继续执行操作**    

- 100 continue：继续，客户端应继续请求     
- 101 ：切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议

（2）**200状态码：成功处理了请求的状态码**

- 200 OK：服务器已成功处理了请求并提供了请求的网页。     
- 201 Created：对于那些要服务器创建对象的请求来说，资源已创建完毕。     

- 202 Accepted：已接受。已经接受请求，但未处理完成。     
- 204  No Content： 服务器成功处理了请求，但没有返回任何内容。

（3）**300状态码：重定向，每次请求中使用重定向不要超过 5 次**

重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。  

- 301：请求的网页已永久移动到新位置。返回信息会包括新的URI，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替     
- 302：请求的网页临时移动到新位置。但资源只是临时被移动。客户端应继续使用原有URI     
- 304 Not Modified：如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。因为客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源，而此时发现客户端的缓存资源是最新的，则直接使用缓存即可。

（4）**400状态码：客户端请求错误，表示请求可能出错，妨碍了服务器的处理**     

- 400 Bad Request： 客户端请求的语法错误，服务器无法理解。     
- 403 Forbidden： 服务器理解客户端的请求，但是拒绝执行次请求。     

- 404 Not Found：服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。     

- 410 ：请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404 代码。如果资源已永久删除，应当使用 301 指定资源的新位置。

（5）**500状态码：服务器错误，表示服务器在处理请求时发生内部错误。**

这些错误可能是服务器本身的错误，而不是请求出错。     

- 500 ：服务器内部错误，无法完成请求。     
- 503： 服务器目前无法使用（由于超载或停机维护）。



### 3.5、HTTP请求报文/响应报文格式

**HTTP请求报文格式**：

<img src="D:\笔记\Typora\Tpora笔记\图片\计算机网络\HTTP请求报文结构.png" alt="HTTP请求报文结构" style="zoom:67%;" />



示例：

<img src="D:\笔记\Typora\Tpora笔记\图片\计算机网络\请求报文示例.png" alt="请求报文示例" style="zoom:60%;" />

**HTTP响应报文格式**：

![HTTP响应报文结构](D:\笔记\Typora\Tpora笔记\图片\计算机网络\HTTP响应报文结构.png)

举例：

![响应报文示例](D:\笔记\Typora\Tpora笔记\图片\计算机网络\响应报文示例.png)

### 3.4、Get和Post的区别

（1）GET请求可被**缓存、收藏、保留到历史记录**中去，而post不行。GET请求的参数会显示在URL当中，POST则会显示在HTML的请求体中，所以POST更加安全。

（2）GET方式提交的参数URL有限制（在特定的浏览器或操作系统中），而POST一般没有此限制。

（3）GET具有**幂等性**，POST不具有（即理论上一次GET请求和N次GET请求的结果相同。）因为GET一般只从服务器获取资源而不改变，POST有可能改变服务器上的该资源。

（4）GET请求的数据类型只允许**ASCII字符**，POST则对数据类型没有要求，也允许二进制数据。

（5）若是回退浏览器，GET请求无影响，POST则会**重新提交表单**。

它们的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。

### 3.5、从浏览器输入URL到访问页面详细过程

（1）先要根据域名获得IP地址，先访问浏览器的DNS缓存，没有的话找操作系统DNS缓存，还没有就本地DNS服务器缓存，还没有迭代或者递归查询（找其他DNS服务器，根域名服务器等（递归：等会我，我问别人去。迭代：你去问小明。）获得IP。

（2）根据端口号和ip地址封装TCP连接请求（传输层）。

（3）选择合适的包路径并转发包。（网络层）

（4）ARP协议获得该ip地址对应的MAC地址（网络层与数据链路层之间）。

（5）成功建立三次握手。

（6）客户端发送http请求（应用层）。

（7）服务器响应请求。

（8）获得对应的html文件，并且继续重复该过程发送请求获得其他在HTML中的资源，如：js，css文件等。

（9）最后呈现在用户面前一个完整的页面。







